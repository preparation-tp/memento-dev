---
sidebar_position: 5
title: "State et cycle de vie"
description: "Voyons ensemble comment gÃ©rer le state et le cycle de vie d'un composant React !"
tags:
  - Frontend
  - React
  - JavaScript/TypeScript
  - BibliothÃ¨que
  - Interface utilisateur (UI)
---

import Admonition from '@theme/Admonition';
import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

# State et cycle de vie

## Introduction

Dans le prÃ©cÃ©dent article, nous avons vu comment crÃ©er notre premier composant React avec notamment le concept de **props**.

Voyons maintenant comment gÃ©rer le **state** et le **cycle de vie** d'un composant React !  
CommenÃ§ons tranquillement avec le **cycle de vie** d'un composant, puisqu'il est indispensable pour comprendre le **state**.

<Admonition type="info" title="Rappel">
  Dans cet article, on va utiliser des composants fonctionnels _(fonctions)_ plutÃ´t que des composants de classe _(classes)_ pour dÃ©clarer nos composants React.  
  Pour rappel, les composants dÃ©clarÃ©s avec des classes ne sont plus recommandÃ©s par la [documentation officielle](https://react.dev/reference/react/Component).
</Admonition>

## ğŸ”„ Cycle de vie

Le **cycle de vie** d'un composant React est une sÃ©rie d'Ã©tapes que traverse un composant, de sa crÃ©ation _(montage)_ Ã  sa destruction _(dÃ©montage)_.

Voici les trois diffÃ©rentes Ã©tapes du cycle de vie d'un composant React :

1. **Montage** _(Mounting)_ : le composant est crÃ©Ã© et insÃ©rÃ© dans le DOM
2. **Mise Ã  jour** _(Updating)_ : le composant est mis Ã  jour suite Ã  un changement de **props** ou de **state**
3. **DÃ©montage** _(Unmounting)_ : le composant est retirÃ© du DOM

On verra un peu plus en dÃ©tail ces Ã©tapes dans l'article suivant qui traitera un certain hook de React : `useEffect`.

<Admonition type="quote" title="Hook.. comme le capitaine ? ğŸ¦œğŸ´â€â˜ ï¸">
  Haha, non !

  Un hook en React, est une fonction qui permet d'exploiter les fonctionnalitÃ©s de React dans un composant fonctionnel _(fonction)_.

  Bon... c'est un peu du charabia, mais on verra Ã§a plus en dÃ©tail dans le prochain article car il y a beaucoup Ã  dire sur les hooks !
</Admonition>

Mais pour le moment, restons en Ã  une vue d'ensemble du cycle de vie !

## ğŸ§  State

Le **state** est un objet qui contient les donnÃ©es internes d'un composant.  
Il est propre Ã  chaque composant et peut Ãªtre modifiÃ© par ce dernier _(Ã  ne pas confondre avec les **props** qui elles sont immuables)_.

Mais alors, pourquoi utiliser un state alors qu'on pourrait tout simplement dÃ©clarer une variable dans notre composant ?

Prenons cet exemple :

<Tabs>
  <TabItem value="js" label="JavaScript">
    ```jsx title="Counter.jsx" showLineNumbers
    import React from 'react';

    export const Counter = () => {
      let count = 0;

      const increment = () => {
        count += 1;
        console.log("Increment", count);
      };

      return (
        <button onClick={increment}>{count}</button>
      );
    };
    ```
  </TabItem>

  <TabItem value="ts" label="TypeScript">
    ```tsx title="Counter.tsx" showLineNumbers
    import React from 'react';

    export const Counter = () => {
      let count: number = 0;

      const increment = () => {
        count += 1;
        console.log("Increment", count);
      };

      return (
        <button onClick={increment}>{count}</button>
      );
    };
    ```
  </TabItem>
</Tabs>

On serait tentÃ©s de croire que ce code fonctionne. AprÃ¨s tout, en vanilla JS _(JavaScript pur)_, on pourrait tout Ã  fait faire Ã§a !  
Et maintenant tu t'en doutes _(sinon pourquoi j'en parlerai ?)_, ce code ne fonctionne pas.

Pourtant, si on regarde la console du navigateur on voit bien que la variable `count` est bien incrÃ©mentÃ©e !

La raison est trÃ¨s simple : React ne sait pas que la variable `count` a Ã©tÃ© modifiÃ©e.  
Pour Ãªtre plus prÃ©cis, React ne sait pas qu'il doit mettre Ã  jour l'interface utilisateur _(UI)_ suite Ã  la modification de `count`.

C'est lÃ  qu'intervient le **state** !  
Le state est **rÃ©actif** et permet Ã  React de savoir quand il doit mettre Ã  jour l'interface utilisateur _(UI)_.

### ğŸ“ DÃ©claration du state

Pour dÃ©clarer un **state**, on utilise le hook `useState` de React.  

<Tabs>
  <TabItem value="js" label="JavaScript">
    ```jsx
    const [count, setCount] = React.useState(0);
    ```
  </TabItem>

  <TabItem value="ts" label="TypeScript">
    ```tsx
    const [count, setCount] = React.useState<number>(0);
    ```
  </TabItem>
</Tabs>

Et lÃ  tu vas peut-Ãªtre te demander une chose...

<Admonition type="quote" title="Ouh lÃ ... pourquoi on a deux assignements ?">
  Bien vu ! Effectivement on va avoir deux assignements pour dÃ©clarer un **state** :
  - `count` : la valeur du **state**
  - `setCount` : la fonction qui permet de modifier la valeur du **state**

  Si tu as dÃ©jÃ  fait de la POO, le principe de **getter** et **setter** te sera familier puisque c'est un peu le mÃªme principe !

  Le hook `useState` prend en paramÃ¨tre la valeur initiale du **state** _(ici `0`)_ et retourne un tableau avec la valeur du **state** et la fonction pour le modifier.
</Admonition>

### ğŸ”„ Utilisation du state

Maintenant que notre **state** est dÃ©clarÃ©, on peut l'utiliser dans notre composant.

<Tabs>
  <TabItem value="js" label="JavaScript">
    ```jsx title="Counter.jsx" showLineNumbers
    import React from 'react';

    export const Counter = () => {
      const [count, setCount] = React.useState(0);

      const increment = () => setCount(count + 1);

      return (
        <button onClick={increment}>{count}</button>
      );
    };
    ```
  </TabItem>

  <TabItem value="ts" label="TypeScript">
    ```tsx title="Counter.tsx" showLineNumbers
    import React from 'react';

    export const Counter = () => {
      const [count, setCount] = React.useState<number>(0);

      const increment = () => setCount(count + 1);

      return (
        <button onClick={increment}>{count}</button>
      );
    };
    ```
  </TabItem>
</Tabs>

Et voilÃ  ! Pas besoin de plus pour gÃ©rer un **state** en React ğŸ˜‰

Mais qu'est-ce qu'il se passe sous le capot ?  
C'est un peu plus complexe que Ã§a, mais pour faire simple :

#### âš™ï¸ Montage du composant _(Mounting)_
On vient prÃ©venir React que notre composant va avoir un **state** et on lui donne une valeur initiale _(ici `0`)_.

#### ğŸ”§ Mise Ã  jour du composant _(Updating)_
Ce state, Ã  chaque modification, va dÃ©clencher un nouveau rendu du composant.

#### ğŸ—‘ï¸ DÃ©montage du composant _(Unmounting)_
Et enfin, quand le composant est retirÃ© du DOM, le state est dÃ©truit avec lui.

Ce fonctionnement est identique pour les props donnÃ©s Ã  un composant d'ailleurs !  
React est vraiment bien fait pour Ã§a ğŸ˜Š

## Conclusion

PlutÃ´t simple, non ?  
Alors maintenant que tu sais comment gÃ©rer le **state** et le **cycle de vie** d'un composant React, tu es prÃªt Ã  te pencher sur la prochaine Ã©tape _(et pas des moindres)_ : les **hooks** !

Mais pour l'heure, je te laisse jouer avec les **states** et les **props** pour bien comprendre comment tout Ã§a fonctionne.