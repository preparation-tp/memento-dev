---
sidebar_position: 8
title: "Le hook useReducer de React"
description: "D√©couvrez comment utiliser le hook useReducer de React pour g√©rer l'√©tat de vos composants de mani√®re plus efficace."
tags:
  - Frontend
  - React
  - JavaScript/TypeScript
  - Biblioth√®que
  - Interface utilisateur (UI)
---

import Button from '@site/src/components/Button';
import Quiz from '@site/src/components/Quiz';
import Admonition from '@theme/Admonition';
import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

# L'utilisation des reducers avec React

## Introduction

Si tu as lu les pr√©c√©dentes pages concernant les hooks de React _(`useState`, `useEffect` et `useContext`)_, tu as d√©j√† une bonne vision de la mani√®re dont tu peux concevoir une application React.

Mais si je te dis que tu peux aller encore plus loin avec `useReducer` pour la gestion des √©tats, est-ce que tu serais int√©ress√©¬∑e ? ü§î

<Admonition type="quote" title="Pourquoi ? useState ne suffit pas ?">
  Le hook `useState` est g√©nial et essentiel pour g√©rer l'√©tat local d'un composant, mais il n'est pas adapt√© pour des √©tats dits "complexes" ou pour des √©tats qui d√©pendent les uns des autres.
</Admonition>

## Qu'est-ce que le hook `useReducer` ?

Le hook `useReducer` est une alternative √† `useState` qui est plus adapt√©e pour g√©rer des √©tats complexes ou des √©tats qui d√©pendent les uns des autres.

Il est bas√© sur le concept de [**reducers**](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers) que l'on retrouve dans la [biblioth√®que Redux](https://redux.js.org).

Un reducer est une fonction qui prend en param√®tre un √©tat et une action, et qui retourne un nouvel √©tat. Il permet un d√©coupage plus fin de la logique de gestion de l'√©tat.

Mais avant de rentrer dans les d√©tails, donnons des exemples de quand utiliser `useReducer` ou `useState` !

### Quand utiliser `useState` ?

Si tu dois stocker un √©tat simple, comme un bool√©en, un nombre ou une cha√Æne de caract√®res, alors `useState` est parfait pour cela.

Ne te casse donc pas la t√™te √† remplacer tous tes `useState` par des `useReducer` si tu n'en as pas besoin. üòÖ

### Quand utiliser `useReducer` ?

D√®s que l'on a des √©tats complexes ou des √©tats qui d√©pendent les uns des autres, il est recommand√© d'utiliser `useReducer`.

Par exemple, si tu as un formulaire avec plusieurs champs, et que tu veux g√©rer l'√©tat de chaque champ de mani√®re ind√©pendante, alors `useReducer` est une bonne solution.

√áa te permettra d'√©viter de cr√©er des tonnes de `useState` et/ou handlers pour chaque champ du formulaire.

Mais `useReducer` n'est pas seulement utile pour les formulaires, il peut √™tre utilis√© dans de nombreux cas, comme la gestion d'un panier d'achat, la gestion d'une ressource, etc.

## √Ä quoi ressemble un reducer ?

Comme expliqu√© plus t√¥t, un reducer est une fonction qui prend en param√®tre un √©tat et une action, et qui retourne un nouvel √©tat.

Parlons dans un premier temps de la signature d'un reducer :

<Tabs>
  <TabItem value="js" label="JavaScript">
    ```jsx
    const reducer = (state, action) => {
      switch (action.type) {
        case 'TYPE_1':
          return { ...state, /* Nouvel √©tat */ };
        case 'TYPE_2':
          return { ...state, /* Nouvel √©tat */ };
        default:
          return state;
      }
    };
    ```
  </TabItem>

  <TabItem value="ts" label="TypeScript">
    ```jsx
    const reducer = (state: State, action: Action) => {
      switch (action.type) {
        case 'TYPE_1':
          return { ...state, /* Nouvel √©tat */ };
        case 'TYPE_2':
          return { ...state, /* Nouvel √©tat */ };
        default:
          return state;
      }
    };
    ```
  </TabItem>
</Tabs>

Comme tu peux le voir, on r√©cup√®re bien deux param√®tres : `state` et `action`.

Le `state` est l'√©tat actuel du composant, et l'`action` est un objet qui contient un type et d'autres propri√©t√©s.

En fonction du type de l'action, on retourne un nouvel √©tat.  
Par d√©faut _(c'est-√†-dire si le type de l'action n'est pas reconnu)_, on retourne l'√©tat actuel sans l'alt√©rer.

Dans le reducer, il est strictement impossible d'alt√©rer l'√©tat actuel directement.  
L'√©tat est contraint au principe d'**immutabilit√©**.

On fera donc des `return` de l'√©tat actuel avec les modifications n√©cessaires.

<Admonition type="quote" title="Pourquoi d√©verser le contenu de l'√©tat actuel ?">
  Si on ne d√©verse pas le contenu de l'√©tat actuel, on perdrait les propri√©t√©s qui ne sont pas modifi√©es par l'action.

  En d√©versant le contenu de l'√©tat actuel, on s'assure de ne pas perdre ces propri√©t√©s.

  Par exemple :
  ```jsx
  const initialState = { count: 0, message: 'Hello' };

  const reducer = (state, action) => {
    switch (action.type) {
      case 'INCREMENT':
        return { count: state.count + 1 };
      default:
        return state;
    }
  };
  ```

  On perdrait ici la propri√©t√© `message` si on ne la d√©versait pas dans le nouvel √©tat.
</Admonition>

## Comment utiliser `useReducer` ?

Maintenant que tu as une id√©e de ce qu'est un reducer, voyons comment l'utiliser avec le hook `useReducer` au sein d'une application React ! üöÄ

Naturellement, on va commencer par importer le hook `useReducer` :

```jsx
import { useReducer } from 'react';
```

Ensuite, on va d√©finir notre √©tat initial :

<Tabs>
  <TabItem value="js" label="JavaScript">
    ```jsx
    const initialState = { count: 0 };
    ```
  </TabItem>

  <TabItem value="ts" label="TypeScript">
    ```tsx
    type State = {
      count: number;
    };

    const initialState: State = {
      count: 0,
    };
    ```
  </TabItem>
</Tabs>

On peut maintenant d√©finir notre reducer :

<Tabs>
  <TabItem value="js" label="JavaScript">
    ```jsx
    const reducer = (state, action) => {
      switch (action.type) {
        case "INCREMENT":
          return { count: state.count + 1 };
        case "DECREMENT":
          return { count: state.count - 1 };
        case "RESET":
          return { count: 0 };
        case "SET":
          return { count: action.payload };
        default:
          return state;
      }
    };
    ```
  </TabItem>

  <TabItem value="ts" label="TypeScript">
    ```tsx
    type State = {
      count: number;
    };

    type Action = {
      type: "INCREMENT" | "DECREMENT" | "RESET" | "SET";
      payload?: number;
    };

    const reducer = (state: State, action: Action) => {
      switch (action.type) {
        case "INCREMENT":
          return { count: state.count + 1 };
        case "DECREMENT":
          return { count: state.count - 1 };
        case "RESET":
          return { count: 0 };
        case "SET":
          return { count: action.payload! };
        default:
          return state;
      }
    };
    ```
  </TabItem>
</Tabs>

<Admonition type="quote" title="C'est quoi `action.payload!` ?">
  La propri√©t√© `payload` de l'action est optionnelle. Il s'agit d'une convention pour passer des donn√©es √† l'action.

  Le `!` apr√®s `action.payload` signifie que l'on est s√ªr que `payload` est d√©fini.  
  Cela permet d'√©viter une erreur de type avec TypeScript.

  Dans le cas du type `SET`, le payload sera d√©fini obligatoirement avec un nombre qui sera la nouvelle valeur de la propri√©t√© `count` de l'√©tat.
</Admonition>

Enfin, on peut utiliser le hook `useReducer` dans notre composant :

<Tabs>
  <TabItem value="js" label="JavaScript">
    ```jsx
    const [state, dispatch] = useReducer(reducer, initialState);
    ```
  </TabItem>

  <TabItem value="ts" label="TypeScript">
    ```tsx
    const [state, dispatch] = useReducer(reducer, initialState);
    ```
  </TabItem>
</Tabs>

`state` contient l'√©tat actuel, et `dispatch` est une fonction qui permet d'envoyer une action au reducer.

Pour modifier l'√©tat, on va donc appeler `dispatch` avec une action :

```jsx
dispatch({ type: 'INCREMENT' });
```

Et voil√†, tu sais maintenant comment utiliser `useReducer` dans une application React ! üéâ

## On nettoie tout √ßa !

Tout ce qui t'a √©t√© montr√© plus haut fonctionne, mais est-ce que pour autant ce code est qualitatif ? ü§î

**Non !**
