---
sidebar_position: 8
title: "CP 8"
description: "SynthÃ¨se de la CP 8 \"Documenter le dÃ©ploiement d'une application dynamique web ou web mobile\" du titre professionnel DÃ©veloppeur Web et Web Mobile (DWWM TP-01280m04)."
tags:
  - DWWM
  - DÃ©ploiement
  - Back-end
  - Reverse Proxy
  - Serveur web
---

import Admonition from "@theme/Admonition";

# Documenter le dÃ©ploiement d'une application dynamique web ou web mobile

## ğŸ“š RÃ©fÃ©rences

- REAC _(mise Ã  jour du 03/07/2024)_, page 29
- RE _(mise Ã  jour du 03/07/2024)_, page 12

## ğŸ“‹ En rÃ©sumÃ©

Allez, on clos la derniÃ¨re compÃ©tence professionnelle de ce millÃ©sime 2023 avec la documentation du dÃ©ploiement !  
Et heureusement, on n'attend pas de toi de maÃ®triser un serveur dans les dÃ©tails, mais d'expliquer **comment** mettre en ligne ton projet.

Tu as le droit d'utiliser des plateformes de dÃ©ploiement en ligne comme Vercel, Netlify, Heroku, etc.  
Mais la comprÃ©hension, mÃªme basique, d'un serveur Linux est quelque chose d'extrÃªmement apprÃ©ciÃ© et enrichissant.

## ğŸ¤– Les plateformes de dÃ©ploiement en ligne

Selon la plateforme utilisÃ©e, la procÃ©dure de dÃ©ploiement peut varier. Certaines plateformes peuvent dÃ©ployer automatiquement ton projet Ã  partir de ton dÃ©pÃ´t Git, d'autres nÃ©cessitent de passer par la ligne de commande pour `push` une branche spÃ©cifique sur le serveur de la plateforme.

C'est Ã  toi _(et ton Ã©quipe)_ de choisir la plateforme qui vous convient le mieux et de documenter la procÃ©dure de dÃ©ploiement afin que tout le monde puisse s'y retrouver.

## ğŸ¤ Les serveurs mutualisÃ©s

Beaucoup d'hÃ©bergeurs proposent des serveurs mutualisÃ©s, c'est-Ã -dire que plusieurs sites web partagent les ressources d'un mÃªme serveur _(mÃªme si tu n'es pas le responsable des autres sites hÃ©bergÃ©s sur le serveur)_.

Il s'agit d'une solution moins coÃ»teuse que les serveurs dÃ©diÃ©s ou les VPS, mais qui peut Ãªtre moins performante en fonction de la qualitÃ© de l'hÃ©bergeur.  
Cependant, pour un site web de petite ou moyenne envergure, un serveur mutualisÃ© peut suffire et surtout : il est souvent plus simple Ã  gÃ©rer.

<details>

<summary>ParenthÃ¨se Ã©co-conception</summary>

On peut Ã©galement considÃ©rer que l'utilisation de serveurs mutualisÃ©s est plus Ã©cologique, car elle permet de mutualiser les ressources et de limiter le nombre de serveurs physiques nÃ©cessaires pour hÃ©berger des sites web.

Moins de matÃ©riel physique = moins de consommation d'Ã©nergie = moins d'Ã©missions de CO2.

</details>

Mais attention, les serveurs mutualisÃ©s ne permettent pas de configurer entiÃ¨rement le serveur _(par exemple, tu ne pourras pas installer un serveur Node.js sur un serveur mutualisÃ© qui n'est pas prÃ©vu pour)_.  
Il est donc important de bien se renseigner sur les fonctionnalitÃ©s proposÃ©es par l'hÃ©bergeur avant de choisir un serveur mutualisÃ©.

## ğŸ”¨ Les serveurs dÃ©diÃ©s et VPS

Maintenant, le meilleur du meilleur : les serveurs dÃ©diÃ©s et les VPS !  
Ã‡a peut faire peur sur le papier car on devient l'unique gestionnaire et responsable du serveur, mais c'est certainement la meilleure faÃ§on de comprendre comment fonctionne un serveur web.

La configuration la plus classique que l'on retrouvera sur un serveur dÃ©diÃ© ou un VPS est la suivante :

- Un systÃ¨me d'exploitation headless _(sans interface graphique, Ã  l'ancienne ! ğŸ‘´)_ comme Ubuntu Server, CentOS, Debian, etc.
- Un serveur web comme Apache, Nginx, ou Caddy
- Une ou plusieurs bases de donnÃ©es comme MySQL, PostgreSQL, MongoDB, etc.
- Un serveur de langage comme Node.js, PHP, Ruby, Python, etc.
- Un gestionnaire de processus comme PM2, Supervisor, etc.
- Un gestionnaire de paquets comme APT, YUM, etc.
- Un pare-feu comme UFW, iptables, etc.

<details>

<summary>DerniÃ¨re parenthÃ¨se Ã©co-conception</summary>

Les serveurs dÃ©diÃ©s et les VPS sont souvent plus Ã©nergivores que les serveurs mutualisÃ©s, car ils sont allumÃ©s en permanence _(sauf configuration spÃ©cifique)_ et consomment plus d'Ã©nergie pour fonctionner.

Sur le papier, Ã§a sonne moins bien, mais dans le concret : un serveur dÃ©diÃ© ou un VPS bien configurÃ© peut Ãªtre plus Ã©cologique qu'un serveur mutualisÃ© mal configurÃ© _(qui consomme plus d'Ã©nergie pour moins de performance)_.
Comme on dit souvent :

<Admonition type="quote" title="Le problÃ¨me se situe souvent entre la chaise et le clavier" />

Si tu recherches un hÃ©bergeur qui se veut Ã©co-responsable _(bien plus que la moyenne)_ : Infomaniak est un excellent choix.  
_(Non, je ne dÃ©tiens aucune part chez eux, mais j'apprÃ©cie leur dÃ©marche et leur qualitÃ© de service donc un peu de pub gratuite ne fait pas de mal !)_

D'ailleurs, sur toute la partie RGPD : Infomaniak a une politique de confidentialitÃ© et de sÃ©curitÃ© trÃ¨s sÃ©rieuse que tu peux retrouver [juste ici](https://www.infomaniak.com/fr/cgv/reglement-general-protection-donnees).  
Et promis : elle est lisible et comprÃ©hensible, pas comme certaines politiques de confidentialitÃ© qui sont plus longues que l'intÃ©grale de la saga Harry Potter.

</details>

Avant d'arrÃªter de parler de serveurs Ã  configurer soi-mÃªme, je me permets d'ouvrir une toute petite rubrique sur la mise en ligne d'applications tournant sur des ports autres que le 80 (ou 443 pour le HTTPS), comme on peut le faire avec un serveur Node.js.

## ğŸšª Les reverse proxies

Un serveur web classique Ã©coute sur les ports 80 et 443 pour les requÃªtes HTTP et HTTPS.  
Sauf que ton application va probablement tourner sur d'autres ports, que ce soit 3000, 5000 ou je ne sais quel autre numÃ©ro.

Notre objectif avec les reverse proxies, c'est de lier un domaine _(sur les ports 80 et 443)_ Ã  un port interne spÃ©cifique de notre serveur.  
C'est un peu comme une "pseudo-redirection", mais qui sera invisible pour l'utilisateur.

### ğŸ“¦ Nginx

Nginx est un serveur web qui est souvent utilisÃ© comme reverse proxy, notamment pour sa simplicitÃ© de configuration et sa syntaxe nettement moins verbeuse que celle d'Apache.

Prenons l'exemple d'un serveur Node.js qui tourne sur le port 5000.

<Admonition type="example" title="Configuration Nginx pour un reverse proxy">
```nginx showLineNumbers
# Ensemble de configurations pour un serveur Nginx
server {
    listen 80; # Port 80 pour les requÃªtes HTTP
    listen [::]:80; # Port 80 pour les requÃªtes HTTP en IPv6
    server_name mon-domaine.com; # Ton domaine qui pointe vers ton serveur web qui fait tourner ton application Node.js

    # Configuration pour le reverse proxy, qui va rediriger les requÃªtes vers le port 5000
    location / {
        proxy_pass          http://0.0.0.0:5000; # Redirige les requÃªtes vers le port 5000 (interne au serveur)
        proxy_set_header    X-Forwarded-For $remote_addr; # Envoie l'adresse IP du client Ã  l'application Node.js dans le header
        proxy_set_header    Host $http_host; # Envoie le nom de domaine Ã  l'application Node.js dans le header
    }
}
```

Oui, c'est aussi simple que Ã§a ! Alors effectivement, il y a d'autres configurations possibles, mais pour un usage basique : c'est tout ce dont tu as besoin.
</Admonition>


### ğŸ“¦ Caddy

Caddy est un serveur web qui se veut simple Ã  configurer et qui propose de nombreuses fonctionnalitÃ©s "out-of-the-box", comme la gestion automatique des certificats SSL _(gratuits)_ avec Let's Encrypt.

Pour le coup je n'ai pas encore eu l'occasion de faire des tests avec Caddy, mais je sais que la configuration pour un reverse proxy est extrÃªmement simple, voire plus simple que celle de Nginx.

### ğŸ“¦ Apache

On ne le prÃ©sente plus, Apache est certainement **le** serveur web le plus utilisÃ© au monde.  
Au delÃ  d'Ãªtre d'Ãªtre installÃ© par dÃ©faut avec toutes les solutions type Wamp, Xampp, Mamp, etc., on utilise rÃ©guliÃ¨rement Apache sur de vrais serveurs.

Sa configuration est un peu plus verbeuse que celle de Nginx, mais si Ã§a t'intÃ©resse de dÃ©couvrir Apache : je t'invite Ã  consulter la [documentation officielle](https://httpd.apache.org/docs/2.4/).

## â“ Les autres solutions

Il existe d'autres solutions pour dÃ©ployer une application web, mais je pense que tu as dÃ©jÃ  pas mal de lecture pour aujourd'hui.

Par contre, il y a **une solution** que je te recommande de ne **jamais utiliser** : les serveurs FTP.  
Alors oui, c'est pratique, c'est simple, mais on attend de toi une approche de dÃ©veloppeur !

Tu as de nombreux outils spÃ©cialement conÃ§us pour le dÃ©ploiement, l'automatisation, la gestion de versions, etc.  
C'est ton rÃ´le d'utiliser ces outils pour dÃ©ployer ton projet, et non pas de faire du simple drag-n-drop de fichiers via FTP et attendre 45 minutes pour transfÃ©rer un dossier de 10 Mo _(oui, j'ai dÃ©jÃ  vu Ã§a et mÃªme bien pire que Ã§a quand on se souvient qu'on a des node_modules ou les dÃ©pendances PHP dans le dossier vendor ğŸ¤¡)_.

## ğŸ¯ CritÃ¨res d'Ã©valuation

- La procÃ©dure de dÃ©ploiement est rÃ©digÃ©e ou mise Ã  jour
- Les scripts de dÃ©ploiement sont Ã©crits et documentÃ©s
- Le systÃ¨me de veille permet de suivre les Ã©volutions technologiques et les problÃ©matiques de sÃ©curitÃ© liÃ©es au dÃ©ploiement d'une application dynamique web ou web mobile, y compris dans le cadre d'une dÃ©marche DevOps

---

## ğŸ§  Documentations

- [Nginx](https://nginx.org/en/docs/)
- [Caddy](https://caddyserver.com/docs/)
- [Apache](https://httpd.apache.org/docs/2.4/)
- [Let's Encrypt](https://letsencrypt.org/docs/)

## ğŸ› ï¸ Outils

- [Infomaniak](https://www.infomaniak.com/fr)
- [Vercel](https://vercel.com/)
- [Netlify](https://www.netlify.com/)
- [Heroku](https://www.heroku.com/)
